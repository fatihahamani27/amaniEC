#Different : The function es_comma indicates the (μ, λ) evolutionary strategy, where only offspring are considered for selection, 
#while es_plus differentiates between the two, retaining parents in each iteration.

# evolution strategy (mu + lambda) of the ackley objective function
from numpy import asarray
from numpy import exp
from numpy import sqrt
from numpy import cos
from numpy import e
from numpy import pi
from numpy import argsort
from numpy.random import randn
from numpy.random import rand
from numpy.random import seed

# objective function
def objective(v):
	x, y = v
	return -20.0 * exp(-0.2 * sqrt(0.5 * (x**2 + y**2))) - exp(0.5 * (cos(2 * pi * x) + cos(2 * pi * y))) + e + 20

# check if a point is within the bounds of the search
def in_bounds(point, bounds):
	# enumerate all dimensions of the point
	for d in range(len(bounds)):
		# check if out of bounds for this dimension
		if point[d] < bounds[d, 0] or point[d] > bounds[d, 1]:
			return False
	return True

  # Combined evolution strategy function
def es_combined(objective, bounds, n_iter, step_size, mu, lam, switch_strategy="comma", switch_epoch=None, improvement_threshold=1e-6):
    best, best_eval = None, float("inf")
    n_children = int(lam / mu)
    
    # Initial population
    population = []
    for _ in range(lam):
        candidate = None
        while candidate is None or not in_bounds(candidate, bounds):
                     candidate = bounds[:, 0] + rand(len(bounds)) * (bounds[:, 1] - bounds[:, 0])
        population.append(candidate)

    # Perform the search
    for epoch in range(n_iter):
        # Evaluate fitness for the population
        scores = [objective(c) for c in population]
        
        # Rank scores in ascending order
        ranks = argsort(scores)
        
        # Select the indexes for the top mu ranked solutions
        selected = [ranks[i] for i in range(mu)]
        
        # Create children from parents
        children = []
        for i in selected:
            parent = population[i]
            for _ in range(n_children):
                # Create a child around the parent
                child = None
                while child is None or not in_bounds(child, bounds):
                    child = parent + randn(len(bounds)) * step_size
                children.append(child)
        
        # Decide on the selection strategy based on switch_strategy and conditions
        if switch_strategy == "comma":
            # (μ, λ) strategy - Replace population only with offspring
            population = children
        elif switch_strategy == "plus":
            # (μ + λ) strategy - Combine parents and offspring, select the best
            combined_population = population + children
            combined_scores = [objective(c) for c in combined_population]
            combined_ranks = argsort(combined_scores)
            population = [combined_population[i] for i in combined_ranks[:mu]]
        elif switch_strategy == "hybrid":
            # Hybrid approach: switch based on epoch or improvement threshold
            if (switch_epoch and epoch >= switch_epoch) or (epoch > 0 and abs(best_eval - min(scores)) < improvement_threshold):
                # Use (μ + λ) strategy
                combined_population = population + children
                combined_scores = [objective(c) for c in combined_population]
                combined_ranks = argsort(combined_scores)
                population = [combined_population[i] for i in combined_ranks[:mu]]
            else:
                # Use (μ, λ) strategy
                population = children

        # Track the best solution found
        for i in range(mu):
            if scores[i] < best_eval:
                best, best_eval = population[i], scores[i]
                print(f"{epoch}: Best f({best}) = {best_eval:.5f}")

    return best, best_eval

# Seed the pseudorandom number generator
seed(1)

# Define range for input
bounds = asarray([[-5.0, 5.0], [-5.0, 5.0]])

# Define the total iterations
n_iter = 100
# Define the maximum step size
step_size = 0.15
# Number of parents selected
mu = 20
# Number of children generated by parents
lam = 100

# Perform the combined evolution strategy search
best, score = es_combined(objective, bounds, n_iter, step_size, mu, lam, switch_strategy="hybrid", switch_epoch=50)
print(f"Done! Best Solution: f({best}) = {score:.5f}")

